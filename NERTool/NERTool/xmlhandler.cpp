#include "xmlhandler.h"


/******************************************************************************
 * XML Handler for NER tool.
 * Manages the loading of subtitles and transcriptions and the project's export
 * configuration.
 ******************************************************************************/

XMLHandler::XMLHandler(QWidget *parent)
{
    _parent = parent;
}

XMLHandler::~XMLHandler()
{

}

/*******************************************************************************
 * Handles the import of TRS XML files (generated by Transcriber application)
 * Args:
 *
 ******************************************************************************/
bool XMLHandler::readTranscriberXML(QString &xmlFilePath,
                                    QList<BlockTRS> *trsBlocks,
                                    QList<Speaker> *speakerList)
{
    if(QFile::exists(xmlFilePath)){
        QFile *xmlFile = new QFile(xmlFilePath);
        if(xmlFile->open(QIODevice::ReadOnly | QIODevice::Text))
        {
            bool isOk = loadTranscriberXML(xmlFile, trsBlocks, speakerList);
            xmlFile->close();
            delete xmlFile;
            return isOk;
        }
    }

    return false;
}

bool XMLHandler::readSRTTranscription(QString &xmlFilePath,
                                    QList<BlockTRS> *trsBlocks)
{
    if(QFile::exists(xmlFilePath)){
        QFile *xmlFile = new QFile(xmlFilePath);
        if(xmlFile->open(QIODevice::ReadOnly | QIODevice::Text))
        {
            bool isOk = loadSRTTranscription(xmlFile, trsBlocks);
            xmlFile->close();
            delete xmlFile;
            return isOk;
        }
    }

    return false;
}

bool XMLHandler::readSubtitleXML(QString &xmlFilePath,
                                 QList<BlockTRS> *trsBlocks)
{
    if(QFile::exists(xmlFilePath)){
        QFile *xmlFile = new QFile(xmlFilePath);
        if(xmlFile->open(QIODevice::ReadOnly | QIODevice::Text))
        {
             bool isOk = loadSubtitleXML(xmlFile, trsBlocks);
             xmlFile->close();
             delete xmlFile;

            return isOk;
        }
    }

    return false;

}

/******************************************************************************
 * Loads the transcription XML format into the GUI's table...
 *
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE Trans SYSTEM "trans-14.dtd">
    <Trans scribe="Juan Martinez" audio_filename="ner_10vor10_2012-09-27_Audio" version="1" version_date="121026">
    <Speakers>
        <Speaker id="spk1" name="Journalist 1" check="no" type="female" dialect="native" accent="" scope="local"/>
        <Speaker id="spk2" name="Christine Maier" check="no" type="female" dialect="native" accent="" scope="local"/>
        <Speaker id="spk3" name="Stefan Reinhart" check="no" type="male" dialect="native" accent="" scope="local"/>
    </Speakers>
    <Episode>
        <Section type="report" startTime="0" endTime="85.6555102041">
            <Turn startTime="0" endTime="5.361" speaker="spk1" mode="planned" fidelity="high" channel="studio">
                <Sync time="0"/>
                zustandekommen, will die Bundeskanzlei n�chste Woche bekanntgeben.
            </Turn>
            <Turn speaker="spk2" mode="planned" fidelity="high" channel="studio" startTime="5.361" endTime="19.947">
                <Sync time="5.361"/>
                Falls das Referendum gegen das Abkommen mit Deutschland tats�chlich zustande kommt, w�rden die Schweizer Ende November dar�ber abstimmen.
                <Sync time="12.189"/>
                Stefan Reinhard in Berlin, was h�tte das dann f�r einen Einfluss auf die deutsche Politik, wo das Abkommen ebenfalls auf der Kippe steht?
            </Turn>
            <Turn mode="planned" fidelity="high" startTime="19.947" endTime="21.747" channel="studio">
                <Sync time="19.947"/>

            </Turn>
        </Section>
    </Episode>
    </Trans>
 *
 ******************************************************************************/
bool XMLHandler::loadTranscriberXML(QFile *xmlFile,
                                    QList<BlockTRS> *trsBlocks,
                                    QList<Speaker> *speakerList){

    QString syncTime;
    QString speaker;

    QXmlStreamReader *xmlReader = new QXmlStreamReader(xmlFile);
    QXmlStreamAttributes attrs;

    while(!xmlReader->atEnd() && !xmlReader->hasError()) {

        /* Read next element.*/
        xmlReader->readNext();


        /* If token is just StartDocument, we'll go to next.*/
        if(xmlReader->isStartDocument() ) {
            qDebug("\tisStartDocument...");
            continue;
        }

        if(xmlReader->isCharacters() ) {
            qDebug("\tisCharacters from Sync...");
            if(!xmlReader->text().toString().trimmed().isEmpty()){
                BlockTRS btr;
                QString textFinal = xmlReader->text().toString().trimmed();
                textFinal.replace(",",", ");
                btr.setSpeaker(speaker).setSyncTime(syncTime).setText(textFinal);
                trsBlocks->append(btr);
                //qDebug(btr.toString().toAscii());
            }
            continue;
        }

        /* If token is StartElement, we'll see if we can read it.*/
        if(xmlReader->isStartElement()) {
            if(xmlReader->name() == STR_SPEAKERS){
                qDebug("\tSpeakers block...");
                continue;
            }

            if(xmlReader->name() == STR_SPEAKER){
                qDebug("\tspeaker...");
                //Read Speaker attributes
                QXmlStreamAttributes attrs = xmlReader->attributes();
                const QString id = attrs.value(STR_SPEAKER_ID).toString();
                const QString name = attrs.value(STR_SPEAKER_NAME).toString();
                const QString type = attrs.value(STR_SPEAKER_TYPE).toString();
                Speaker sp;
                sp.setId(id).setName(name).setType(type);
                speakerList->append(sp);
                continue;
            }

            if(xmlReader->name() == STR_TRANS) {
                //Ignore it for the moment...
                qDebug("\tReading transcritption block...");
                continue;
            }
            if(xmlReader->name() == STR_EPISODE) {
                qDebug("\tReading episode block...");
                continue;

            }
            if(xmlReader->name() == STR_SECTION){
                continue;
            }
            if(xmlReader->name() == STR_TURN){
                attrs = xmlReader->attributes();
                speaker = attrs.value(STR_TURN_SPEAKER).toString();
                continue;
            }
            else if(xmlReader->name() == STR_SYNC){
                qDebug("\tReading Sync block...");
                attrs = xmlReader->attributes();
                syncTime = attrs.value(STR_SYNC_TIME).toString();
                continue;
            }
            
        }


        if(xmlReader->isEndElement()) {
            qDebug("\tClosing block...");
            continue;
        }
        if(xmlReader->isEndDocument()) {
            qDebug("\tEnd document block...");
            continue;
        }
    }

    return true;
}

bool XMLHandler::loadSRTTranscription(QFile *srtFile, QList<BlockTRS> *trsBlocks)
{

    QTextStream *inTextStream = new QTextStream(srtFile);
    //inTextStream->setAutoDetectUnicode(true);
    inTextStream->setCodec("UTF-8");

    int index=0;//index of the SRT
    QString line;//current read line
    QString formatedTime;
    QString text;//subtitle text obtained from several reads.
    QString startTime;
    QString endTime;

    //Check if the file is a SRT...
    QString line1 = inTextStream->readLine();
    QString line2 = inTextStream->readLine();
    bool isNumber;
    line1.toInt(&isNumber);
    bool hasArrow = line2.contains("-->");

    if(!isNumber && !hasArrow){
        //if first line does not contain a number and the second does not
        //contain an "-->" its not a well formatted SRT file...
        return false; //get out!
    }

    inTextStream->seek(0);

    while(!inTextStream->atEnd()){
        //read line from the stream
        line = inTextStream->readLine();

        //check if the line is a number
        bool okIsNumber;
        int valueIndex = line.toInt(&okIsNumber);

        if(line.isEmpty() && index>0 && !text.isEmpty()) {

            bool isTimeSRTOk = true;
            //Load TRS Block
            QString timeF = startTime.simplified();
            formatedTime = getFormatedTime(timeF, isTimeSRTOk);

            if(!isTimeSRTOk){
                return false; //Something's wrong with the SRT.
            }

            BlockTRS btr;
            btr.setSyncTime(formatedTime).setText(Utils::removeBlanksBeforePonctuation(text).simplified());

            trsBlocks->append(btr);

            //set start and stop time.
            //clear the text to read a new subtitle line.
            text.clear();
            formatedTime.clear();
            //no more verifications to do. skip to the next line...
            continue;
        }
        else if(okIsNumber){
            //is a number so clear the accumulated text buffer.
            text.clear();
            index = valueIndex;
        }
        else if(line.contains("-->"))
        {
            QStringList list = line.split("-->");
            startTime = list.first();
            endTime = list.last();
        }
        else{
            //is simple text
            text.append(line).append(" ");
        }
    }

    //Save last line...
    bool isTimeSRTOk = true;
    //Load TRS Block
    QString timeF = startTime.simplified();
    formatedTime = getFormatedTime(timeF, isTimeSRTOk);
    BlockTRS btr;
    btr.setSyncTime(formatedTime).setText(Utils::removeBlanksBeforePonctuation(text).simplified());
    trsBlocks->append(btr);

    inTextStream->flush();

    delete(inTextStream);

    return true;
}

/*******************************************************************************
 * Loads the subtitles represented in the transcriber format.
 ******************************************************************************/
bool XMLHandler::loadSubtitleXML(QFile *xmlFile, QList<BlockTRS> *trsBlocks)
{
    QString syncTime;
    QString speaker;

    QXmlStreamReader *xmlReader = new QXmlStreamReader(xmlFile);
    QXmlStreamAttributes attrs;

    while(!xmlReader->atEnd() && !xmlReader->hasError()) {

        /* Read next element.*/
        xmlReader->readNext();


        /* If token is just StartDocument, we'll go to next.*/
        if(xmlReader->isStartDocument() ) {
            qDebug("\tisStartDocument...");
            continue;
        }

        if(xmlReader->isCharacters() ) {
            qDebug("\tisCharacters from Sync...");
            if(!xmlReader->text().toString().trimmed().isEmpty()){
                BlockTRS btr;
                QString textFinal = xmlReader->text().toString().trimmed();
                textFinal.replace(",",", ");
                btr.setSpeaker(speaker).setSyncTime(syncTime).setText(textFinal);
                trsBlocks->append(btr);
                //qDebug(btr.toString().toAscii());
            }
            continue;
        }

        /* If token is StartElement, we'll see if we can read it.*/
        if(xmlReader->isStartElement()) {
            if(xmlReader->name() == STR_SPEAKERS){
                continue;
            }

            if(xmlReader->name() == STR_SPEAKER){
                continue;
            }

            if(xmlReader->name() == STR_TRANS) {
                continue;
            }
            else if(xmlReader->name() == STR_EPISODE) {
                continue;
            }
            if(xmlReader->name() == STR_SECTION){
                continue;
            }
            if(xmlReader->name() == STR_TURN){
                attrs = xmlReader->attributes();
                speaker = attrs.value(STR_TURN_SPEAKER).toString();
                continue;
            }
            else if(xmlReader->name() == STR_SYNC){
                qDebug("\tReading Sync block...");
                attrs = xmlReader->attributes();
                syncTime = attrs.value(STR_SYNC_TIME).toString();
                continue;
            }

        }

        //Closing tags.....
        if(xmlReader->isEndElement()) {
            qDebug("\tClosing block...");
            continue;
        }
        if(xmlReader->isEndDocument()) {
            qDebug("\tEnd document block...");
            continue;
        }
    }

    return true;
}


bool XMLHandler::readSubtitleSRT(QString &srtFile, QList<BlockTRS> *trsBlocks)
{
    QFile *file = new QFile(srtFile);
    QTextStream *inTextStream = new QTextStream(file);
    inTextStream->setCodec("UTF-8");
    //inTextStream->setAutoDetectUnicode(true);

    int index=0;//index of the SRT
    QString line;//current read line
    QString formatedTime;
    QString text;//subtitle text obtained from several reads.
    QString startTime;
    QString endTime;

    if(!file->open(QFile::ReadOnly))
    {
        return false;
    }

    //Check if the file is a SRT...
    QString line1 = inTextStream->readLine();
    QString line2 = inTextStream->readLine();
    bool isNumber;
    line1.toInt(&isNumber);
    bool hasArrow = line2.contains("-->");

    if(!isNumber && !hasArrow){
        //if first line does not contain a number and the second does not
        //contain an "-->" its not a well formatted SRT file...
        return false; //get out!
    }

    inTextStream->seek(0);

    while(!inTextStream->atEnd()){
        //read line from the stream
        line = inTextStream->readLine();

        //check if the line is a number
        bool okIsNumber;
        int valueIndex = line.toInt(&okIsNumber);



        if(line.isEmpty() && index>0 && !text.isEmpty()) {

            bool isTimeSRTOk = true;
            //Load TRS Block
            QString timeF = startTime.simplified();
            formatedTime = getFormatedTime(timeF, isTimeSRTOk);

            if(!isTimeSRTOk){
                return false; //Something's wrong with the SRT.
            }

            BlockTRS btr;

            btr.setSyncTime(formatedTime).setText(Utils::removeBlanksBeforePonctuation(text).simplified());

            trsBlocks->append(btr);

            //set start and stop time.
            //clear the text to read a new subtitle line.
            text.clear();
            valueIndex = -1;

            //no more verifications to do. skip to the next line...
            continue;
        }
        else if(okIsNumber){
            //is a number so clear the accumulated text buffer.
            text.clear();
            index = valueIndex;
        }
        else if(line.contains("-->"))
        {
            QStringList list = line.split("-->");
            startTime = list.first();
            endTime = list.last();
        }
        else{
            //is simple text
            text.append(line).append(" ");
        }
    }

    //Save last line...
    bool isTimeSRTOk = true;
    //Load TRS Block
    QString timeF = startTime.simplified();
    formatedTime = getFormatedTime(timeF, isTimeSRTOk);
    BlockTRS btr;
    btr.setSyncTime(formatedTime).setText(Utils::removeBlanksBeforePonctuation(text).simplified());
    trsBlocks->append(btr);

    file->close();

    delete(inTextStream);
    delete(file);

    return true;
}

/*******************************************************************************
 * Formats SRT file format to TRS format.
 *
 ******************************************************************************/
QString XMLHandler::getFormatedTime(QString &time, bool &isTimeSRTOk)
{
    QString ret;
    if(time.isEmpty()){
        return ret;
    }

    //SRT Time example: 00:00:20,990
    QStringList list = time.split(",");

    if(list.count() != 2){
        isTimeSRTOk = false; //badly formatted SRT
        return ret;
    }

    QString leftTime = list.at(0);
    QString milis = list.at(1);

    QStringList list2 = leftTime.split(":");
    if(list2.count() != 3){
        isTimeSRTOk = false; //badly formatted SRT
        return ret;
    }

    QString hours = list2.at(0);
    QString minutes = list2.at(1);
    QString second = list2.at(2);

    int seconds = hours.toInt()*3600 + minutes.toInt()*60 + second.toInt();

    ret.append(QString::number(seconds)).append(".").append(milis);

    return ret;
}

/*******************************************************************************
 * Writes the projects XML export content
 ******************************************************************************/
bool XMLHandler::writeProjectExportXML(QString &xmlFileName,
                                       QList<Speaker> *speakerList,
                                       QList<BlockTRS> *transcription,
                                       QTreeWidgetItem *transcTreeNode,
                                       QMap<QTreeWidgetItem*, QMdiSubWindow*> *subWindowsMap)
{

    QFile *file = new QFile(xmlFileName);

    if (!file->open(QIODevice::WriteOnly | QIODevice::Text)) {
        return false;
    }


    QXmlStreamWriter *xmlWriter = new QXmlStreamWriter();
    xmlWriter->setDevice(file);

    xmlWriter->setAutoFormatting(true);
    xmlWriter->writeStartDocument();

    xmlWriter->writeComment("************************************************");
    xmlWriter->writeComment("* NER Export File XML");
    xmlWriter->writeComment("************************************************");

    xmlWriter->writeStartElement(STR_NER_PROJECT);
    xmlWriter->writeAttribute(STR_NER_PROJECT_PROP_SAVEDATE,
                              QDateTime::currentDateTime().toString());

    xmlWriter->writeComment("NER Original Transcription and Speakers Block");

    xmlWriter->writeStartElement(STR_TRANSC_TAG);

    QString name, responsible, description;
    if(transcTreeNode!=NULL){
        name = transcTreeNode->text(0);
        responsible = transcTreeNode->text(1);
        description = transcTreeNode->text(2);
    }

    xmlWriter->writeAttribute(STR_TRANSC_PROP_NAME, name);
    xmlWriter->writeAttribute(STR_TRANSC_RESPONSIBLE, responsible);
    xmlWriter->writeAttribute(STR_TRANSC_DESCRIPTION, description);

    xmlWriter->writeStartElement(STR_SPEAKERS_TAG);

    for(int i=0; i<speakerList->count(); i++)
    {
        Speaker sp = speakerList->at(i);

        xmlWriter->writeStartElement(STR_SPEAKER_TAG);
        xmlWriter->writeAttribute(STR_SPEAKER_PROP_ID, sp.getId());
        xmlWriter->writeAttribute(STR_SPEAKER_PROP_NAME, sp.getName());
        xmlWriter->writeAttribute(STR_SPEAKER_PROP_TYPE, sp.getType());
        xmlWriter->writeEndElement();
    }
    xmlWriter->writeEndElement();//end Speaker tag

    for(int i=0; i<transcription->count(); i++)
    {
        BlockTRS btr = transcription->at(i);
        QString speaker, syncTime, sText;
        speaker = btr.getSpeaker();
        syncTime = btr.getSyncTime();
        sText = btr.getText();

        xmlWriter->writeStartElement(STR_TRANSC_LINE_TAG);
        xmlWriter->writeAttribute(STR_TRANSC_LINE_PROP_SPEAKER, speaker);
        xmlWriter->writeAttribute(STR_TRANSC_LINE_PROP_TIMESTAMP, syncTime);
        xmlWriter->writeAttribute(STR_TRANSC_LINE_PROP_TEXT, sText);
        xmlWriter->writeEndElement();//end TranscLine tag

    }
    xmlWriter->writeEndElement();//end Transcription block...


    /*********************************************
     * Export all the included subtitle tables...
     *********************************************/
    xmlWriter->writeComment("*******************************");
    xmlWriter->writeComment("* NER Comparison Tables Block *");
    xmlWriter->writeComment("*******************************");

    xmlWriter->writeStartElement(STR_TABLES_TAG);

    const QList<QTreeWidgetItem*> tableTreeNodes = subWindowsMap->keys();

    for(int t=0; t < tableTreeNodes.count(); t++)
    {
        xmlWriter->writeStartElement(STR_TABLE_TAG);

        QTreeWidgetItem* treeItem = tableTreeNodes.at(t);
        QMdiSubWindow* subWindow = subWindowsMap->value(treeItem);

        if(treeItem==0 || subWindow==0){
            continue;
        }

        const NERTableWidget* tableWidget = static_cast<NERTableWidget*>(subWindow->widget());


        const QString name = treeItem->text(0);
        const QString resp = treeItem->text(1);
        const QString desc = treeItem->text(2);

        const QString assessment = tableWidget->getAssessment();

        xmlWriter->writeAttribute(STR_TABLE_PROP_NAME, name);
        xmlWriter->writeAttribute(STR_TABLE_PROP_RESPONSIBLE, resp);
        xmlWriter->writeAttribute(STR_TABLE_PROP_DESCRIPTION, desc);
        xmlWriter->writeAttribute(STR_TABLE_PROP_ASSESSMENT, assessment);

        for(int row=0; row<tableWidget->rowCount(); row++)
        {
            xmlWriter->writeStartElement(STR_TABLELINE_TAG);

            const QString speakerS = tableWidget->item(row, SPEAKER_ID_COLUMN_INDEX)->text();
            xmlWriter->writeAttribute(STR_TABLELINE_PROP_SID, speakerS);
            const QString timeS = tableWidget->item(row, TIMESTAMP_COLUMN_INDEX)->text();
            xmlWriter->writeAttribute(STR_TABLELINE_PROP_TIMESTAMP, timeS);
            DragWidget* transWidget = static_cast<DragWidget*>(tableWidget->cellWidget(row, TRANSCRIPTION_COLUMN_INDEX));
            const QString dwText = transWidget->getText();
            xmlWriter->writeAttribute(STR_TABLELINE_PROP_TRANSCRIP, dwText);

            //Save the transcription annotations and weights...
            xmlWriter->writeStartElement(STR_TRANSC_LINE_WORDS);

            QList<DragLabel*> transLabList = transWidget->getLabels();
            for(int m=0; m<transLabList.count(); m++)
            {
                DragLabel* label = transLabList.at(m);

                xmlWriter->writeStartElement(STR_TRANSC_LINE_WORD);

                const QString labelText = label->labelText();
                xmlWriter->writeAttribute(STR_WORD_PROP_NAME, labelText);
                const QString errorT = QString::number(label->getErrorType());
                xmlWriter->writeAttribute(STR_WORD_PROP_ERROR, errorT);
                const QString comment = label->getComment();
                xmlWriter->writeAttribute(STR_WORD_PROP_COMMENT, comment);
                const QString errorW = QString::number(label->getErrorWeight());
                xmlWriter->writeAttribute(STR_WORD_PROP_WEIGHT, errorW);
                const QString errorC = QString::number(label->getErrorClass());
                xmlWriter->writeAttribute(STR_WORD_PROP_CLASS, errorC);

                xmlWriter->writeEndElement();//STR_TRANSC_LINE_WORD
            }


            xmlWriter->writeEndElement();


            NERSubTableWidget* subTable = static_cast<NERSubTableWidget*>(tableWidget->cellWidget(row, SUBTITLES_COLUMN_INDEX));
            if(subTable == 0){
                //no subtable was stored...
                //proceed to next line...
                continue;
            }

            for(int w=0; w < subTable->rowCount(); w++)
            {
                xmlWriter->writeStartElement(STR_SUBTABLELINE_TAG);
                xmlWriter->writeAttribute(STR_SUBTABLELINE_PROP_TIMESTAMP, subTable->item(w,0)->text());

                DragWidget* dragWidget = static_cast<DragWidget*>(subTable->cellWidget(w,1));

                for(int z=0; z<dragWidget->countWords(); z++){

                    xmlWriter->writeStartElement(STR_WORD_TAG);
                    DragLabel* label = dragWidget->getWordAt(z);
                    const QString labelText = label->labelText();
                    xmlWriter->writeAttribute(STR_WORD_PROP_NAME, labelText);
                    const QString errorT = QString::number(label->getErrorType());
                    xmlWriter->writeAttribute(STR_WORD_PROP_ERROR, errorT);
                    const QString comment = label->getComment();
                    xmlWriter->writeAttribute(STR_WORD_PROP_COMMENT, comment);
                    const QString errorW = QString::number(label->getErrorWeight());
                    xmlWriter->writeAttribute(STR_WORD_PROP_WEIGHT, errorW);
                    const QString errorC = QString::number(label->getErrorClass());
                    xmlWriter->writeAttribute(STR_WORD_PROP_CLASS, errorC);
                    xmlWriter->writeEndElement();//STR_WORD_TAG
                }
                xmlWriter->writeEndElement();//STR_SUBTABLELINE_TAG
            }
            xmlWriter->writeEndElement();//STR_TABLELINE_TAG
        }
        xmlWriter->writeEndElement();//STR_TABLE_TAG
    }
    xmlWriter->writeEndElement();//STR_TABLES_TAG

    xmlWriter->writeEndElement();//end NerProject
    xmlWriter->writeEndDocument();

    //Close file descriptor
    file->close();
    if (file->error()) {
        QMessageBox warningMessage;
        warningMessage.setText("There was an error closing the export file.");
        warningMessage.setWindowTitle("Warning");
        warningMessage.setIcon(QMessageBox::Warning);
        warningMessage.exec();
        return false;
    }

    delete xmlWriter;//free mem
    return true;
}


bool XMLHandler::readProjectExportXML(QString &xmlFileName,
                                      QList<Speaker> *speakerList,
                                      QList<BlockTRS> *transcription,
                                      QList<NERTableWidget *> *nerTablesList,
                                      MediaMngWidget *mediaWid,
                                      PropertiesTreeWidget *treeWidget)
{
    QFile *file = new QFile(xmlFileName);

    if (!file->open(QIODevice::ReadOnly | QIODevice::Text)) {
        return false;
    }


    bool isLoadingATable = false;
    NERTableWidget* currentTable;

    NERSubTableWidget* currentSubtable;
    QList<DragLabel*> subTableLineLabels;
    QList<DragLabel*> currentTransLineLabels;
    DragWidget* currentTransLineDragWid;
    DragWidget* currentDragWid;

    QString currentSubTabTimeStamp;

    QList<BlockTRS> subitlesList;


    QXmlStreamReader *xmlReader = new QXmlStreamReader();
    xmlReader->setDevice(file);

    while(!xmlReader->atEnd() && !xmlReader->hasError())
    {
        /* Read next element.*/
        xmlReader->readNext();


        /* If token is just StartDocument, we'll go to next.*/
        if(xmlReader->isStartDocument() ) {
            ENGINE_DEBUG << ">>> Start Doc";
            continue;
        }

        if(xmlReader->isStartElement()){
            if(xmlReader->name()==STR_NER_PROJECT){
                ENGINE_DEBUG << ">>> New Project";
                continue;
            }
            if(xmlReader->name()==STR_TRANSC_TAG){
                ENGINE_DEBUG << ">>> Transcription";
                QXmlStreamAttributes attributes = xmlReader->attributes();
                QString name = attributes.value(STR_TRANSC_PROP_NAME).toString();
                QString resp = attributes.value(STR_TRANSC_RESPONSIBLE).toString();
                QString desc = attributes.value(STR_TRANSC_DESCRIPTION).toString();

                treeWidget->insertNewTranslation(name, resp, desc);

                continue;
            }
            if(xmlReader->name()==STR_TRANSC_LINE_TAG){
                ENGINE_DEBUG << ">>> Transcription Line";

                QXmlStreamAttributes attributes = xmlReader->attributes();
                const QString timeStamp = attributes.value(STR_TRANSC_LINE_PROP_TIMESTAMP).toString();
                const QString speakerId = attributes.value(STR_TRANSC_LINE_PROP_SPEAKER).toString();
                const QString text = attributes.value(STR_TRANSC_LINE_PROP_TEXT).toString();

                BlockTRS btr;
                btr.setSyncTime(timeStamp).setSpeaker(speakerId).setText(text);
                transcription->append(btr);

                continue;
            }

            if(xmlReader->name()==STR_SPEAKERS_TAG){
                ENGINE_DEBUG << ">>> Speakers ";

                QXmlStreamAttributes attributes = xmlReader->attributes();
                const QString speakerID = attributes.value(STR_SPEAKER_PROP_ID).toString();
                const QString speakerName = attributes.value(STR_SPEAKER_PROP_NAME).toString();
                const QString speakerType = attributes.value(STR_SPEAKER_PROP_TYPE).toString();
                Speaker sp;
                sp.setId(speakerID).setId(speakerName).setType(speakerType);
                speakerList->append(sp);
            }

            if(xmlReader->name()==STR_TABLES_TAG){
                ENGINE_DEBUG << ">>> Tables Tag";

                continue;
            }

            if(xmlReader->name()==STR_TABLE_TAG){
                ENGINE_DEBUG << ">>> A table...";

                //Read all the table...
                isLoadingATable = true;

                currentTable = new NERTableWidget(_parent);
                currentTable->setMediaWidget(mediaWid);

                nerTablesList->append(currentTable);

                QXmlStreamAttributes attribs = xmlReader->attributes();
                QString tableName = attribs.value(STR_TABLE_PROP_NAME).toString();
                QString responsible = attribs.value(STR_TABLE_PROP_RESPONSIBLE).toString();
                QString description = attribs.value(STR_TABLE_PROP_DESCRIPTION).toString();
                QString assessment = attribs.value(STR_TABLE_PROP_ASSESSMENT).toString();

                currentTable->setTableName(tableName);
                currentTable->setResponsible(responsible);
                currentTable->setDescription(description);
                currentTable->setAssessment(assessment);

                ENGINE_DEBUG << ">>> Table props:\n\t" << tableName
                             << "\n\t" << responsible
                             << "\n\t" << description;

                continue;
            }

            if(xmlReader->name() == STR_TABLELINE_TAG){
                ENGINE_DEBUG << "Table Line...";

                QXmlStreamAttributes attribs = xmlReader->attributes();
                QString speakerID = attribs.value(STR_TABLELINE_PROP_SID).toString();
                QString timeStamp = attribs.value(STR_TABLELINE_PROP_TIMESTAMP).toString();
                QString transcription = attribs.value(STR_TABLELINE_PROP_TRANSCRIP).toString();//Check if needed...

                currentTable->insertNewTableEntry(speakerID, timeStamp);

                currentTransLineDragWid = new DragWidget(_parent, TRANSCRIPTION_COLUMN_WIDTH, true);

                currentSubtable = new NERSubTableWidget(_parent);
                currentSubtable->setMediaWidget(mediaWid);

                continue;
            }

            if(xmlReader->name() == STR_SUBTABLELINE_TAG){
                QXmlStreamAttributes attribs = xmlReader->attributes();
                currentSubTabTimeStamp = attribs.value(STR_SUBTABLELINE_PROP_TIMESTAMP).toString();

                currentDragWid = new DragWidget(_parent, SUBTITLES_COLUMN_WIDTH-30, true);

                continue;
            }

            if(xmlReader->name()==STR_WORD_TAG){
                //Collect all the words... when it's time addet to a subtable...
                QXmlStreamAttributes attribs = xmlReader->attributes();
                QString name = attribs.value(STR_WORD_PROP_NAME).toString();
                QString errorType = attribs.value(STR_WORD_PROP_ERROR).toString();
                QString weigth = attribs.value(STR_WORD_PROP_WEIGHT).toString();
                QString classType = attribs.value(STR_WORD_PROP_CLASS).toString();
                QString comment = attribs.value(STR_WORD_PROP_COMMENT).toString();

                DragLabel* label = new DragLabel(name, currentDragWid);
                label->setErrorWeight(weigth.toDouble());
                label->setErrorClass(label->modificationTypeFromOrdinal(classType.toInt()));
                label->setupLabelType(label->editionEnumFromOrdinal(errorType.toInt()));
                label->setComment(comment);

                subTableLineLabels.append(label);
                continue;
            }

            if(xmlReader->name()==STR_TRANSC_LINE_WORDS){
                currentTransLineLabels.clear();
            }

            if(xmlReader->name()==STR_TRANSC_LINE_WORD){
                //Collect all the words of a transcription line...
                QXmlStreamAttributes attribs = xmlReader->attributes();
                QString name = attribs.value(STR_WORD_PROP_NAME).toString();
                QString errorType = attribs.value(STR_WORD_PROP_ERROR).toString();
                QString weigth = attribs.value(STR_WORD_PROP_WEIGHT).toString();
                QString classType = attribs.value(STR_WORD_PROP_CLASS).toString();
                QString comment = attribs.value(STR_WORD_PROP_COMMENT).toString();

                DragLabel* label = new DragLabel(name, currentTransLineDragWid);
                label->setErrorWeight(weigth.toDouble());
                label->setErrorClass(label->modificationTypeFromOrdinal(classType.toInt()));
                label->setupLabelType(label->editionEnumFromOrdinal(errorType.toInt()));
                label->setComment(comment);

                currentTransLineLabels.append(label);
                continue;
            }

        }//Start Element


        //Process end elements of interest.
        if(xmlReader->isEndElement()){

            if(xmlReader->name()==STR_SUBTABLELINE_TAG){
                if(currentSubtable!=0 && currentTable!=0){
                    //Add collected data from last loaded subtable...
                    currentDragWid->initializeData(subTableLineLabels);

                    QString dText = currentDragWid->getText();
                    currentTable->insertTimeStampsHashedMap(currentSubTabTimeStamp, dText);

                    //Keep subtitle line...
                    BlockTRS btr;
                    btr.setText(dText.simplified());
                    btr.setSyncTime(currentSubTabTimeStamp);
                    subitlesList.append(btr);

                    currentSubtable->insertNewTableEntry(currentSubTabTimeStamp, currentDragWid);
                    subTableLineLabels.clear();
                }
            }

            if(xmlReader->name()==STR_TABLE_TAG){

                currentTable->setMainDataList(transcription, subitlesList);

                //clear to store subtitles of the next table...
                subitlesList.clear();
            }

            if(xmlReader->name()==STR_TABLELINE_TAG){
                currentTable->insertNewSubtableInLastEntry(currentSubtable);
            }

            if(xmlReader->name()==STR_TRANSC_LINE_WORDS){
                currentTransLineDragWid->initializeData(currentTransLineLabels);
                currentTable->insertTranscriptionLabelInLastEntry(currentTransLineDragWid);
            }
        }

    }//end while

    //Close file descriptor
    file->close();
    if (file->error()) {
        QMessageBox warningMessage;
        warningMessage.setText("There was an error closing the export file.");
        warningMessage.setWindowTitle("Warning");
        warningMessage.setIcon(QMessageBox::Warning);
        warningMessage.exec();
        return false;
    }

    delete xmlReader;//free mem
    return true;
}


/*******************************************************************************
 * Write project report html.
 *
 ******************************************************************************/
bool XMLHandler::writeProjectReport(QString &xmlFileName,
                        QList<NERTableWidget*> *nerTablesList,
                        PropertiesTreeWidget *treeWidget)
{

//    QFile *file = new QFile(xmlFileName);

//    if (!file->open(QIODevice::WriteOnly | QIODevice::Text)) {
//        return false;
//    }



//    QXmlStreamWriter *xmlWriter = new QXmlStreamWriter();
//    xmlWriter->setDevice(file);

//    xmlWriter->setAutoFormatting(true);
//    xmlWriter->writeStartDocument();

//    xmlWriter->writeComment("************************************************");
//    xmlWriter->writeComment("* NER Export File XML");
//    xmlWriter->writeComment("************************************************");

//    xmlWriter->writeStartElement(STR_NER_PROJECT);
//    xmlWriter->writeAttribute(STR_NER_PROJECT_PROP_SAVEDATE,
//                              QDateTime::currentDateTime().toString());

//    xmlWriter->writeComment("NER Original Transcription and Speakers Block");

//    xmlWriter->writeStartElement(STR_TRANSC_TAG);

//    QString name, responsible, description;
//    if(transcTreeNode!=NULL){
//        name = transcTreeNode->text(0);
//        responsible = transcTreeNode->text(1);
//        description = transcTreeNode->text(2);
//    }

//    xmlWriter->writeAttribute(STR_TRANSC_PROP_NAME, name);
//    xmlWriter->writeAttribute(STR_TRANSC_RESPONSIBLE, responsible);
//    xmlWriter->writeAttribute(STR_TRANSC_DESCRIPTION, description);

//    xmlWriter->writeStartElement(STR_SPEAKERS_TAG);

//    for(int i=0; i<speakerList->count(); i++)
//    {
//        Speaker sp = speakerList->at(i);

//        xmlWriter->writeStartElement(STR_SPEAKER_TAG);
//        xmlWriter->writeAttribute(STR_SPEAKER_PROP_ID, sp.getId());
//        xmlWriter->writeAttribute(STR_SPEAKER_PROP_NAME, sp.getName());
//        xmlWriter->writeAttribute(STR_SPEAKER_PROP_TYPE, sp.getType());
//        xmlWriter->writeEndElement();
//    }
//    xmlWriter->writeEndElement();//end Speaker tag

//    for(int i=0; i<transcription->count(); i++)
//    {
//        BlockTRS btr = transcription->at(i);
//        QString speaker, syncTime, sText;
//        speaker = btr.getSpeaker();
//        syncTime = btr.getSyncTime();
//        sText = btr.getText();

//        xmlWriter->writeStartElement(STR_TRANSC_LINE_TAG);
//        xmlWriter->writeAttribute(STR_TRANSC_LINE_PROP_SPEAKER, speaker);
//        xmlWriter->writeAttribute(STR_TRANSC_LINE_PROP_TIMESTAMP, syncTime);
//        xmlWriter->writeAttribute(STR_TRANSC_LINE_PROP_TEXT, sText);
//        xmlWriter->writeEndElement();//end TranscLine tag

//    }
//    xmlWriter->writeEndElement();//end Transcription block...


//    /*********************************************
//     * Export all the included subtitle tables...
//     *********************************************/
//    xmlWriter->writeComment("*******************************");
//    xmlWriter->writeComment("* NER Comparison Tables Block *");
//    xmlWriter->writeComment("*******************************");

//    xmlWriter->writeStartElement(STR_TABLES_TAG);

//    const QList<QTreeWidgetItem*> tableTreeNodes = subWindowsMap->keys();

//    for(int t=0; t < tableTreeNodes.count(); t++)
//    {
//        xmlWriter->writeStartElement(STR_TABLE_TAG);

//        QTreeWidgetItem* treeItem = tableTreeNodes.at(t);
//        QMdiSubWindow* subWindow = subWindowsMap->value(treeItem);

//        if(treeItem==0 || subWindow==0){
//            continue;
//        }

//        const NERTableWidget* tableWidget = static_cast<NERTableWidget*>(subWindow->widget());


//        const QString name = treeItem->text(0);
//        const QString resp = treeItem->text(1);
//        const QString desc = treeItem->text(2);

//        xmlWriter->writeAttribute(STR_TABLE_PROP_NAME, name);
//        xmlWriter->writeAttribute(STR_TABLE_PROP_RESPONSIBLE, resp);
//        xmlWriter->writeAttribute(STR_TABLE_PROP_DESCRIPTION, desc);

//        for(int row=0; row<tableWidget->rowCount(); row++)
//        {
//            xmlWriter->writeStartElement(STR_TABLELINE_TAG);

//            const QString speakerS = tableWidget->item(row, SPEAKER_ID_COLUMN_INDEX)->text();
//            xmlWriter->writeAttribute(STR_TABLELINE_PROP_SID, speakerS);
//            const QString timeS = tableWidget->item(row, TIMESTAMP_COLUMN_INDEX)->text();
//            xmlWriter->writeAttribute(STR_TABLELINE_PROP_TIMESTAMP, timeS);
//            DragWidget* transWidget = static_cast<DragWidget*>(tableWidget->cellWidget(row, TRANSCRIPTION_COLUMN_INDEX));
//            const QString dwText = transWidget->getText();
//            xmlWriter->writeAttribute(STR_TABLELINE_PROP_TRANSCRIP, dwText);


//            NERSubTableWidget* subTable = static_cast<NERSubTableWidget*>(tableWidget->cellWidget(row, SUBTITLES_COLUMN_INDEX));
//            if(subTable == 0){
//                //no subtable was stored...
//                //proceed to next line...
//                continue;
//            }

//            for(int w=0; w < subTable->rowCount(); w++)
//            {
//                xmlWriter->writeStartElement(STR_SUBTABLELINE_TAG);
//                xmlWriter->writeAttribute(STR_SUBTABLELINE_PROP_TIMESTAMP, subTable->item(w,0)->text());

//                DragWidget* dragWidget = static_cast<DragWidget*>(subTable->cellWidget(w,1));

//                for(int z=0; z<dragWidget->countWords(); z++){

//                    xmlWriter->writeStartElement(STR_WORD_TAG);
//                    DragLabel* label = dragWidget->getWordAt(z);
//                    const QString labelText = label->labelText();
//                    xmlWriter->writeAttribute(STR_WORD_PROP_NAME, labelText);
//                    const QString errorT = QString::number(label->getErrorType());
//                    xmlWriter->writeAttribute(STR_WORD_PROP_ERROR, errorT);
//                    const QString comment = label->getComment();
//                    xmlWriter->writeAttribute(STR_WORD_PROP_COMMENT, comment);
//                    const QString errorW = QString::number(label->getErrorWeight());
//                    xmlWriter->writeAttribute(STR_WORD_PROP_WEIGHT, errorW);
//                    const QString errorC = QString::number(label->getErrorClass());
//                    xmlWriter->writeAttribute(STR_WORD_PROP_CLASS, errorC);
//                    xmlWriter->writeEndElement();//STR_WORD_TAG
//                }
//                xmlWriter->writeEndElement();//STR_SUBTABLELINE_TAG
//            }
//            xmlWriter->writeEndElement();//STR_TABLELINE_TAG
//        }
//        xmlWriter->writeEndElement();//STR_TABLE_TAG
//    }
//    xmlWriter->writeEndElement();//STR_TABLES_TAG

//    xmlWriter->writeEndElement();//end NerProject
//    xmlWriter->writeEndDocument();

//    //Close file descriptor
//    file->close();
//    if (file->error()) {
//        QMessageBox warningMessage;
//        warningMessage.setText("There was an error closing the export file.");
//        warningMessage.setWindowTitle("Warning");
//        warningMessage.setIcon(QMessageBox::Warning);
//        warningMessage.exec();
//        return false;
//    }

//    delete xmlWriter;//free mem
//    return true;

    return true;

}








