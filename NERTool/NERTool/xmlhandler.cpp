#include "xmlhandler.h"


/******************************************************************************
 * XML Handler for NER tool.
 * Manages the loading of subtitles and transcriptions and the project's export
 * configuration.
 ******************************************************************************/

XMLHandler::XMLHandler(QWidget *parent)
{
    _parent = parent;
}

XMLHandler::~XMLHandler()
{

}

/*******************************************************************************
 * Handles the import of TRS XML files (generated by Transcriber application)
 * Args:
 *
 ******************************************************************************/
bool XMLHandler::readTranscriberXML(QString &xmlFilePath,
                                    QList<BlockTRS> *trsBlocks,
                                    QList<Speaker> *speakerList)
{
    if(QFile::exists(xmlFilePath)){
        QFile *xmlFile = new QFile(xmlFilePath);
        if(xmlFile->open(QIODevice::ReadOnly | QIODevice::Text))
        {
            return loadTranscriberXML(xmlFile, trsBlocks, speakerList);
        }
    }

    return false;

}

bool XMLHandler::readSubtitleXML(QString &xmlFilePath,
                                 QList<BlockTRS> *trsBlocks)
{
    if(QFile::exists(xmlFilePath)){
        QFile *xmlFile = new QFile(xmlFilePath);
        if(xmlFile->open(QIODevice::ReadOnly | QIODevice::Text))
        {
            return loadSubtitleXML(xmlFile, trsBlocks);
        }
    }

    return false;

}

/******************************************************************************
 * Loads the transcription XML format into the GUI's table...
 *
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE Trans SYSTEM "trans-14.dtd">
    <Trans scribe="Juan Martinez" audio_filename="ner_10vor10_2012-09-27_Audio" version="1" version_date="121026">
    <Speakers>
        <Speaker id="spk1" name="Journalist 1" check="no" type="female" dialect="native" accent="" scope="local"/>
        <Speaker id="spk2" name="Christine Maier" check="no" type="female" dialect="native" accent="" scope="local"/>
        <Speaker id="spk3" name="Stefan Reinhart" check="no" type="male" dialect="native" accent="" scope="local"/>
    </Speakers>
    <Episode>
        <Section type="report" startTime="0" endTime="85.6555102041">
            <Turn startTime="0" endTime="5.361" speaker="spk1" mode="planned" fidelity="high" channel="studio">
                <Sync time="0"/>
                zustandekommen, will die Bundeskanzlei n�chste Woche bekanntgeben.
            </Turn>
            <Turn speaker="spk2" mode="planned" fidelity="high" channel="studio" startTime="5.361" endTime="19.947">
                <Sync time="5.361"/>
                Falls das Referendum gegen das Abkommen mit Deutschland tats�chlich zustande kommt, w�rden die Schweizer Ende November dar�ber abstimmen.
                <Sync time="12.189"/>
                Stefan Reinhard in Berlin, was h�tte das dann f�r einen Einfluss auf die deutsche Politik, wo das Abkommen ebenfalls auf der Kippe steht?
            </Turn>
            <Turn mode="planned" fidelity="high" startTime="19.947" endTime="21.747" channel="studio">
                <Sync time="19.947"/>

            </Turn>
        </Section>
    </Episode>
    </Trans>
 *
 ******************************************************************************/
bool XMLHandler::loadTranscriberXML(QFile *xmlFile,
                                    QList<BlockTRS> *trsBlocks,
                                    QList<Speaker> *speakerList){

    QString syncTime;
    QString speaker;

    QXmlStreamReader *xmlReader = new QXmlStreamReader(xmlFile);
    QXmlStreamAttributes attrs;

    while(!xmlReader->atEnd() && !xmlReader->hasError()) {

        /* Read next element.*/
        xmlReader->readNext();


        /* If token is just StartDocument, we'll go to next.*/
        if(xmlReader->isStartDocument() ) {
            qDebug("\tisStartDocument...");
            continue;
        }

        if(xmlReader->isCharacters() ) {
            qDebug("\tisCharacters from Sync...");
            if(!xmlReader->text().toString().trimmed().isEmpty()){
                BlockTRS btr;
                QString textFinal = xmlReader->text().toString().trimmed();
                textFinal.replace(",",", ");
                btr.setSpeaker(speaker).setSyncTime(syncTime).setText(textFinal);
                trsBlocks->append(btr);
                //qDebug(btr.toString().toAscii());
            }
            continue;
        }

        /* If token is StartElement, we'll see if we can read it.*/
        if(xmlReader->isStartElement()) {
            if(xmlReader->name() == STR_SPEAKERS){
                qDebug("\tSpeakers block...");
                continue;
            }

            if(xmlReader->name() == STR_SPEAKER){
                qDebug("\tspeaker...");
                //Read Speaker attributes
                QXmlStreamAttributes attrs = xmlReader->attributes();
                const QString id = attrs.value(STR_SPEAKER_ID).toString();
                const QString name = attrs.value(STR_SPEAKER_NAME).toString();
                const QString type = attrs.value(STR_SPEAKER_TYPE).toString();
                Speaker sp;
                sp.setId(id).setName(name).setType(type);
                speakerList->append(sp);
                continue;
            }

            if(xmlReader->name() == STR_TRANS) {
                //Ignore it for the moment...
                qDebug("\tReading transcritption block...");
                continue;
            }
            if(xmlReader->name() == STR_EPISODE) {
                qDebug("\tReading episode block...");
                continue;

            }
            if(xmlReader->name() == STR_SECTION){
                continue;
            }
            if(xmlReader->name() == STR_TURN){
                attrs = xmlReader->attributes();
                speaker = attrs.value(STR_TURN_SPEAKER).toString();
                continue;
            }
            else if(xmlReader->name() == STR_SYNC){
                qDebug("\tReading Sync block...");
                attrs = xmlReader->attributes();
                syncTime = attrs.value(STR_SYNC_TIME).toString();
                continue;
            }
            
        }


        if(xmlReader->isEndElement()) {
            qDebug("\tClosing block...");
            continue;
        }
        if(xmlReader->isEndDocument()) {
            qDebug("\tEnd document block...");
            continue;
        }
    }

    return true;
}

/*******************************************************************************
 * Loads the subtitles represented in the transcriber format.
 ******************************************************************************/
bool XMLHandler::loadSubtitleXML(QFile *xmlFile, QList<BlockTRS> *trsBlocks)
{
    QString syncTime;
    QString speaker;

    QXmlStreamReader *xmlReader = new QXmlStreamReader(xmlFile);
    QXmlStreamAttributes attrs;

    while(!xmlReader->atEnd() && !xmlReader->hasError()) {

        /* Read next element.*/
        xmlReader->readNext();


        /* If token is just StartDocument, we'll go to next.*/
        if(xmlReader->isStartDocument() ) {
            qDebug("\tisStartDocument...");
            continue;
        }

        if(xmlReader->isCharacters() ) {
            qDebug("\tisCharacters from Sync...");
            if(!xmlReader->text().toString().trimmed().isEmpty()){
                BlockTRS btr;
                QString textFinal = xmlReader->text().toString().trimmed();
                textFinal.replace(",",", ");
                btr.setSpeaker(speaker).setSyncTime(syncTime).setText(textFinal);
                trsBlocks->append(btr);
                //qDebug(btr.toString().toAscii());
            }
            continue;
        }

        /* If token is StartElement, we'll see if we can read it.*/
        if(xmlReader->isStartElement()) {
            if(xmlReader->name() == STR_SPEAKERS){
                continue;
            }

            if(xmlReader->name() == STR_SPEAKER){
                continue;
            }

            if(xmlReader->name() == STR_TRANS) {
                continue;
            }
            else if(xmlReader->name() == STR_EPISODE) {
                continue;
            }
            if(xmlReader->name() == STR_SECTION){
                continue;
            }
            if(xmlReader->name() == STR_TURN){
                attrs = xmlReader->attributes();
                speaker = attrs.value(STR_TURN_SPEAKER).toString();
                continue;
            }
            else if(xmlReader->name() == STR_SYNC){
                qDebug("\tReading Sync block...");
                attrs = xmlReader->attributes();
                syncTime = attrs.value(STR_SYNC_TIME).toString();
                continue;
            }

        }

        //Closing tags.....
        if(xmlReader->isEndElement()) {
            qDebug("\tClosing block...");
            continue;
        }
        if(xmlReader->isEndDocument()) {
            qDebug("\tEnd document block...");
            continue;
        }
    }

    return true;
}


/*******************************************************************************
 * Writes the projects XML export content
 ******************************************************************************/
bool XMLHandler::writeProjectExportXML(QString &xmlFileName,
                                       QList<Speaker> *speakerList,
                                       QList<BlockTRS> *transcription,
                                       QTreeWidgetItem *transcTreeNode,
                                       QMap<QTreeWidgetItem*, QMdiSubWindow*> *subWindowsMap)
{

    QFile *file = new QFile(xmlFileName);

    if (!file->open(QIODevice::WriteOnly | QIODevice::Text)) {
        return false;
    }


    QXmlStreamWriter *xmlWriter = new QXmlStreamWriter();
    xmlWriter->setDevice(file);

    xmlWriter->setAutoFormatting(true);
    xmlWriter->writeStartDocument();

    xmlWriter->writeComment("************************************************");
    xmlWriter->writeComment("* NER Export File XML");
    xmlWriter->writeComment("************************************************");

    xmlWriter->writeStartElement(STR_NER_PROJECT);
    xmlWriter->writeAttribute(STR_NER_PROJECT_PROP_SAVEDATE,
                              QDateTime::currentDateTime().toString());

    xmlWriter->writeComment("NER Original Transcription and Speakers Block");

    xmlWriter->writeStartElement(STR_TRANSC_TAG);

    QString name, responsible, description;
    if(transcTreeNode!=NULL){
        name = transcTreeNode->text(0);
        responsible = transcTreeNode->text(1);
        description = transcTreeNode->text(2);
    }

    xmlWriter->writeAttribute(STR_TRANSC_PROP_NAME, name);
    xmlWriter->writeAttribute(STR_TRANSC_RESPONSIBLE, responsible);
    xmlWriter->writeAttribute(STR_TRANSC_DESCRIPTION, description);

    xmlWriter->writeStartElement(STR_SPEAKERS_TAG);

    for(int i=0; i<speakerList->count(); i++)
    {
        Speaker sp = speakerList->at(i);

        xmlWriter->writeStartElement(STR_SPEAKER_TAG);
        xmlWriter->writeAttribute(STR_SPEAKER_PROP_ID, sp.getId());
        xmlWriter->writeAttribute(STR_SPEAKER_PROP_NAME, sp.getName());
        xmlWriter->writeAttribute(STR_SPEAKER_PROP_TYPE, sp.getType());
        xmlWriter->writeEndElement();
    }
    xmlWriter->writeEndElement();//end Speaker tag

    for(int i=0; i<transcription->count(); i++)
    {
        BlockTRS btr = transcription->at(i);

        xmlWriter->writeStartElement(STR_TRANSC_LINE_TAG);
        xmlWriter->writeAttribute(STR_TRANSC_LINE_PROP_SPEAKER, btr.getSpeaker());
        xmlWriter->writeAttribute(STR_TRANSC_LINE_PROP_TIMESTAMP, btr.getSyncTime());
        xmlWriter->writeAttribute(STR_TRANSC_LINE_PROP_TEXT, btr.getText());
        xmlWriter->writeEndElement();//end TranscLine tag

    }
    xmlWriter->writeEndElement();//end Transcription block...


    /*********************************************
     * Export all the included subtitle tables...
     *********************************************/
    xmlWriter->writeComment("*******************************");
    xmlWriter->writeComment("* NER Comparison Tables Block *");
    xmlWriter->writeComment("*******************************");

    xmlWriter->writeStartElement(STR_TABLES_TAG);

    QList<QTreeWidgetItem*> tableTreeNodes = subWindowsMap->keys();

    for(int t=0; t < tableTreeNodes.count(); t++)
    {
        xmlWriter->writeStartElement(STR_TABLE_TAG);

        QTreeWidgetItem* treeItem = tableTreeNodes.at(t);
        QMdiSubWindow* subWindow = subWindowsMap->value(treeItem);
        NERTableWidget* tableWidget = static_cast<NERTableWidget*>(subWindow->widget());

        xmlWriter->writeAttribute(STR_TABLE_PROP_NAME, treeItem->text(0));
        xmlWriter->writeAttribute(STR_TABLE_PROP_RESPONSIBLE, treeItem->text(1));
        xmlWriter->writeAttribute(STR_TABLE_PROP_DESCRIPTION, treeItem->text(2));

        for(int row=0; row<tableWidget->rowCount(); row++)
        {
            xmlWriter->writeStartElement(STR_TABLELINE_TAG);

            QString speakerS = tableWidget->item(row, SPEAKER_ID_COLUMN_INDEX)->text();
            xmlWriter->writeAttribute(STR_TABLELINE_PROP_SID, speakerS);
            QString timeS = tableWidget->item(row, TIMESTAMP_COLUMN_INDEX)->text();
            xmlWriter->writeAttribute(STR_TABLELINE_PROP_TIMESTAMP, timeS);
            DragWidget* transWidget = static_cast<DragWidget*>(tableWidget->cellWidget(row, TRANSCRIPTION_COLUMN_INDEX));
            xmlWriter->writeAttribute(STR_TABLELINE_PROP_TRANSCRIP, transWidget->getText());


            NERSubTableWidget* subTable = static_cast<NERSubTableWidget*>(tableWidget->cellWidget(row, SUBTITLES_COLUMN_INDEX));
            if(subTable == 0){
                //no subtable was stored...
                //proceed to next line...
                continue;
            }

            for(int w=0; w < subTable->rowCount(); w++)
            {
                xmlWriter->writeStartElement(STR_SUBTABLELINE_TAG);
                xmlWriter->writeAttribute(STR_SUBTABLELINE_PROP_TIMESTAMP, subTable->itemAt(w,0)->text());

                DragWidget* dragWidget = static_cast<DragWidget*>(subTable->cellWidget(w,1));

                for(int z=0; z<dragWidget->countWords(); z++){

                    xmlWriter->writeStartElement(STR_WORD_TAG);
                    DragLabel* label = dragWidget->getWordAt(z);
                    xmlWriter->writeAttribute(STR_WORD_PROP_NAME, label->labelText());
                    xmlWriter->writeAttribute(STR_WORD_PROP_ERROR, QString::number(label->getErrorType()));
                    xmlWriter->writeAttribute(STR_WORD_PROP_COMMENT, label->getComment());
                    xmlWriter->writeAttribute(STR_WORD_PROP_WEIGHT, QString::number(label->getErrorWeight()));
                    xmlWriter->writeAttribute(STR_WORD_PROP_CLASS, QString::number(label->getErrorClass()));
                    xmlWriter->writeEndElement();//STR_WORD_TAG
                }
                xmlWriter->writeEndElement();//STR_SUBTABLELINE_TAG
            }
            xmlWriter->writeEndElement();//STR_TABLELINE_TAG
        }
        xmlWriter->writeEndElement();//STR_TABLE_TAG
    }
    xmlWriter->writeEndElement();//STR_TABLES_TAG

    xmlWriter->writeEndElement();//end NerProject
    xmlWriter->writeEndDocument();

    //Close file descriptor
    file->close();
    if (file->error()) {
        QMessageBox warningMessage;
        warningMessage.setText("There was an error closing the export file.");
        warningMessage.setWindowTitle("Warning");
        warningMessage.setIcon(QMessageBox::Warning);
        warningMessage.exec();
        return false;
    }

    delete xmlWriter;//free mem
    return true;
}


bool XMLHandler::readProjectExportXML(QString &xmlFileName,
                                      QList<Speaker> *speakerList,
                                      QList<BlockTRS> *transcription,
                                      QList<NERTableWidget *> *nerTablesList,
                                      MediaMngWidget *mediaWid,
                                      PropertiesTreeWidget *treeWidget)
{
    QFile *file = new QFile(xmlFileName);

    if (!file->open(QIODevice::ReadOnly | QIODevice::Text)) {
        return false;
    }


    bool isLoadingATable = false;
    NERTableWidget* currentTable;

    NERSubTableWidget* currentSubtable;
    QList<DragLabel*> subTableLineLabels;
    QString currentSubTabTimeStamp;


    QXmlStreamReader *xmlReader = new QXmlStreamReader();
    xmlReader->setDevice(file);

    while(!xmlReader->atEnd() && !xmlReader->hasError())
    {
        /* Read next element.*/
        xmlReader->readNext();


        /* If token is just StartDocument, we'll go to next.*/
        if(xmlReader->isStartDocument() ) {
            ENGINE_DEBUG << ">>> Start Doc";
            continue;
        }

        if(xmlReader->isStartElement()){
            if(xmlReader->name()==STR_NER_PROJECT){
                ENGINE_DEBUG << ">>> New Project";
                continue;
            }
            if(xmlReader->name()==STR_TRANSC_TAG){
                ENGINE_DEBUG << ">>> Transcription";
                QXmlStreamAttributes attributes = xmlReader->attributes();
                QString name = attributes.value(STR_TRANSC_PROP_NAME).toString();
                QString resp = attributes.value(STR_TRANSC_RESPONSIBLE).toString();
                QString desc = attributes.value(STR_TRANSC_DESCRIPTION).toString();

                treeWidget->insertNewTranslation(name, resp, desc);

                continue;
            }
            if(xmlReader->name()==STR_TRANSC_LINE_TAG){
                ENGINE_DEBUG << ">>> Transcription Line";

                QXmlStreamAttributes attributes = xmlReader->attributes();
                const QString timeStamp = attributes.value(STR_TRANSC_LINE_PROP_TIMESTAMP).toString();
                const QString speakerId = attributes.value(STR_TRANSC_LINE_PROP_SPEAKER).toString();
                const QString text = attributes.value(STR_TRANSC_LINE_PROP_TEXT).toString();

                BlockTRS btr;
                btr.setSyncTime(timeStamp).setSpeaker(speakerId).setText(text);
                transcription->append(btr);

                continue;
            }

            if(xmlReader->name()==STR_SPEAKERS_TAG){
                ENGINE_DEBUG << ">>> Speakers ";

                QXmlStreamAttributes attributes = xmlReader->attributes();
                const QString speakerID = attributes.value(STR_SPEAKER_PROP_ID).toString();
                const QString speakerName = attributes.value(STR_SPEAKER_PROP_NAME).toString();
                const QString speakerType = attributes.value(STR_SPEAKER_PROP_TYPE).toString();
                Speaker sp;
                sp.setId(speakerID).setId(speakerName).setType(speakerType);
                speakerList->append(sp);
            }

            if(xmlReader->name()==STR_TABLES_TAG){
                ENGINE_DEBUG << ">>> Tables Tag";

                continue;

            }
            if(xmlReader->name()==STR_TABLE_TAG){
                ENGINE_DEBUG << ">>> A table...";

                //Read all the table...
                isLoadingATable = true;

                currentTable = new NERTableWidget(_parent);
                currentTable->setMediaWidget(mediaWid);

                nerTablesList->append(currentTable);

                QXmlStreamAttributes attribs = xmlReader->attributes();
                QString tableName = attribs.value(STR_TABLE_PROP_NAME).toString();
                QString responsible = attribs.value(STR_TABLE_PROP_RESPONSIBLE).toString();
                QString description = attribs.value(STR_TABLE_PROP_DESCRIPTION).toString();

                currentTable->setTableName(tableName);
                currentTable->setResponsible(responsible);
                currentTable->setDescription(description);

                ENGINE_DEBUG << ">>> Table props:\n\t" << tableName
                             << "\n\t" << responsible
                             << "\n\t" << description;

                continue;
            }

             if(xmlReader->isEndElement() && xmlReader->name()==STR_TABLE_TAG){
                 continue;
             }

            if(xmlReader->name() == STR_TABLELINE_TAG){
                ENGINE_DEBUG << "Table Line...";

                QXmlStreamAttributes attribs = xmlReader->attributes();
                QString speakerID = attribs.value(STR_TABLELINE_PROP_SID).toString();
                QString timeStamp = attribs.value(STR_TABLELINE_PROP_TIMESTAMP).toString();
                QString transcription = attribs.value(STR_TABLELINE_PROP_TRANSCRIP).toString();

                currentTable->insertNewTableEntry(speakerID, timeStamp, transcription);

                continue;
            }

            if(xmlReader->name() == STR_SUBTABLELINE_TAG){

                if(currentSubtable!=0){
                    //Add collected data from last loaded subtable...
                    currentSubtable->insertNewTableEntry(currentSubTabTimeStamp,
                                                         subTableLineLabels);

                    currentTable->insertNewSubtableInLastEntry(currentSubtable);
                    subTableLineLabels.clear();
                }

                currentSubtable = new NERSubTableWidget(_parent);
                currentSubtable->setMediaWidget(mediaWid);

                QXmlStreamAttributes attribs = xmlReader->attributes();
                currentSubTabTimeStamp = attribs.value(STR_SUBTABLELINE_PROP_TIMESTAMP).toString();

                continue;
            }

            if(xmlReader->name()==STR_WORD_TAG){
                //Collect all the words... when it's time addet to a subtable...
                QXmlStreamAttributes attribs = xmlReader->attributes();
                QString name = attribs.value(STR_WORD_PROP_NAME).toString();
                QString errorType = attribs.value(STR_WORD_PROP_ERROR).toString();
                QString weigth = attribs.value(STR_WORD_PROP_WEIGHT).toString();
                QString classType = attribs.value(STR_WORD_PROP_CLASS).toString();
                QString comment = attribs.value(STR_WORD_PROP_COMMENT).toString();

                DragLabel* label = new DragLabel(name, _parent);
                label->setErrorWeight(weigth.toDouble());
                label->setErrorClass(label->modificationTypeFromOrdinal(classType.toInt()));
                label->setupLabelType(label->editionEnumFromOrdinal(errorType.toInt()));
                label->setComment(comment);

                subTableLineLabels.append(label);
            }
        }

    }//end while


    //Close file descriptor
    file->close();
    if (file->error()) {
        QMessageBox warningMessage;
        warningMessage.setText("There was an error closing the export file.");
        warningMessage.setWindowTitle("Warning");
        warningMessage.setIcon(QMessageBox::Warning);
        warningMessage.exec();
        return false;
    }

    delete xmlReader;//free mem
    return true;
}


bool XMLHandler::readNERTable(QXmlStreamReader *xmlReader,
                              QList<NERTableWidget *> *nerTablesList)
{
    NERTableWidget *table = new NERTableWidget(_parent);

    while(!xmlReader->isEndElement() && xmlReader->name()!=STR_TABLE_TAG)
    {
        xmlReader->readNext();

        QXmlStreamAttributes attribs = xmlReader->attributes();
        QString speaker = attribs.value(STR_TABLELINE_PROP_SID).toString();
        QString timeStamp = attribs.value(STR_TABLELINE_PROP_TIMESTAMP).toString();
        QString text = attribs.value(STR_TABLELINE_PROP_TRANSCRIP).toString();
        //table->insertNewTableEntry(speaker, timeStamp, text);

        //Read all the sub words;
        xmlReader->readNext();

        while(xmlReader->name()==STR_WORD_TAG){

            QXmlStreamAttributes attributes = xmlReader->attributes();
            const QString name = attributes.value(STR_WORD_PROP_NAME).toString();
            const QString error = attributes.value(STR_WORD_PROP_ERROR).toString();
            const QString comment = attributes.value(STR_WORD_PROP_COMMENT).toString();

            xmlReader->readNext();
        }//while...

    }//while...

}










